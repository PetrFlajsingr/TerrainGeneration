#version 430

layout(local_size_x=8, local_size_y=8, local_size_z=8)in;

layout(binding=0, std430)buffer Density{ float density[]; };

uniform vec3 start;
uniform float step;

float hash(float n) { return fract(sin(n) * 1e4); }
float hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }

float noise(vec3 x) {
    const vec3 step = vec3(110, 241, 171);

    vec3 i = floor(x);
    vec3 f = fract(x);

    float n = dot(i, step);

    vec3 u = f * f * (3.0 - 2.0 * f);
    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),
    mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),
    mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),
    mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);
}

float fbm(vec3 x, uint numOctaves) {
    float v = 0.0;
    float a = 0.5;
    vec3 shift = vec3(100);
    for (int i = 0; i < numOctaves; ++i) {
        v += a * noise(x);
        x = x * 2.0 + shift;
        a *= 0.5;
    }
    return v;
}


vec3 getPosition() {
    return start + gl_GlobalInvocationID * vec3(step);
}

uint getIndex() {
    uint dim = 32;
    return gl_GlobalInvocationID.z * dim * dim +
    gl_GlobalInvocationID.y * dim +
    gl_GlobalInvocationID.x;
}

float calculateDensity() {
    vec3 vertex = getPosition();

    float hard_floor_y = 0.1;
    float rad = 3;
    float result = rad - length(vertex - vec3(0, 0, 0));
    result += fbm(vertex.xyz, 5);
    //return (+ vertex.y - vertex.x);
    return -(sqrt(pow(10-vertex.x, 2) + pow(10-vertex.y, 2) + pow(10-vertex.z, 2)) - 5);//-vertex.y + 0.1;
}

void main() {
    density[getIndex()] = calculateDensity();
}