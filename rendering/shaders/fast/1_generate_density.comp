#version 430

layout(local_size_x=8, local_size_y=8, local_size_z=8)in;

layout(binding=0, std430)buffer Density{ float density[]; };

uniform vec3 start;
uniform float step;

uniform vec3 offset;

float hash(float n) { return fract(sin(n) * 1e4); }
float hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }

float noise(vec3 x) {
    const vec3 step = vec3(110, 241, 171);

    vec3 i = floor(x);
    vec3 f = fract(x);

    float n = dot(i, step);

    vec3 u = f * f * (3.0 - 2.0 * f);
    return mix(mix(mix(hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),
    mix(hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),
    mix(mix(hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),
    mix(hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);
}

float fbm(vec3 x, uint numOctaves) {
    float v = 0.0;
    float a = 0.5;
    vec3 shift = vec3(100);
    for (int i = 0; i < numOctaves; ++i) {
        v += a * noise(x);
        x = x * 2.0 + shift;
        a *= 0.5;
    }
    return v;
}


vec3 getPosition() {
    return start + gl_GlobalInvocationID * vec3(step);
}

uint getIndex() {
    uint dim = 32;
    return gl_GlobalInvocationID.z * dim * dim +
    gl_GlobalInvocationID.y * dim +
    gl_GlobalInvocationID.x;
}

float distToSphere(vec3 vertex, vec3 center, float radius) {
    return -(sqrt(pow(center.x-vertex.x, 2) + pow(center.y-vertex.y, 2) + pow(center.z-vertex.z, 2)) - radius);
}

float saturate(float val) {
    return clamp(val, 0.0, 1.0);
}

float calculateDensity() {
    vec3 vertex = getPosition();

    return -vertex.y + (
    + noise(vertex/200)*200
    + noise(vertex/400)*400
    + noise(vertex/1000)*1000
    ) * 1.5;

    /*  float hard_floor_y = 10;
      float rad = 1000;
      return rad - length(vertex - vec3(1000, 1000, 1000)) + (
      + noise(vertex/50)*50
      + noise(vertex/20)*20
      );


      vertex /= 2;
      //vertex.y += 10;
      float result = -vertex.y
      + (noise(vertex/20)*20
      + noise(vertex/10)*10
      + noise(vertex/40)*40
      + noise(vertex/80)*80
      + noise(vertex/4)*4
      ) * 3 * ((sin(vertex.x/50) + sin(vertex.z/50)));
      return result + clamp((hard_floor_y - vertex.y)*3, 0.0, 1.0)*40;*/
}

void main() {
    density[getIndex()] = calculateDensity();
}


























